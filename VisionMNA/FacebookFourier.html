<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mejoramiento de Imágenes con Fourier - Team 13 - Visión Computacional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: linear-gradient(to bottom, #5b7ab5 0%, #3b5998 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #1F497D 0%, #3b5998 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 22px;
            margin-bottom: 8px;
        }
        
        .header p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .institution-info {
            background: white;
            padding: 20px;
            border-bottom: 3px solid #1F497D;
        }
        
        .institution-header {
            text-align: center;
            margin-bottom: 15px;
        }
        
        .institution-header h2 {
            color: #1F497D;
            font-size: 20px;
            margin-bottom: 5px;
        }
        
        .institution-header h3 {
            color: #666;
            font-size: 16px;
            font-weight: normal;
        }
        
        .badges {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin: 12px 0;
        }
        
        .badge {
            background: #1F497D;
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .badge.course {
            background: #FF6B6B;
        }
        
        .badge.activity {
            background: #F9AB00;
        }
        
        .professors {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin: 12px 0;
        }
        
        .professors h4 {
            color: #1F497D;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .professors ul {
            list-style: none;
            padding-left: 0;
        }
        
        .professors li {
            color: #444;
            padding: 4px 0;
            font-size: 13px;
        }
        
        .team-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: white;
        }
        
        .team-section h3 {
            text-align: center;
            font-size: 22px;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .team-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .team-member {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .team-member:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px rgba(0,0,0,0.2);
        }
        
        .team-member img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin-bottom: 10px;
            border: 3px solid #667eea;
            object-fit: cover;
        }
        
        .team-member h4 {
            color: #1F497D;
            font-size: 14px;
            margin-bottom: 6px;
        }
        
        .team-member .matricula {
            color: #667eea;
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 4px;
        }
        
        .team-member .role {
            color: #666;
            font-size: 12px;
        }
        
        .firebase-status {
            background: #2ecc71;
            color: white;
            padding: 8px;
            text-align: center;
            font-weight: bold;
            font-size: 13px;
        }
        
        .firebase-status.disconnected {
            background: #e74c3c;
        }
        
        .content {
            padding: 20px;
        }
        
        .upload-section {
            background: #f6f7f9;
            border: 2px dashed #cbd0d8;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .upload-section h3 {
            font-size: 16px;
            margin-bottom: 12px;
        }
        
        .upload-section input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            background: #4267b2;
            color: white;
            padding: 10px 25px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            display: inline-block;
        }
        
        .upload-btn:hover {
            background: #365899;
        }
        
        .process-btn {
            background: #42b72a;
            color: white;
            padding: 10px 25px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 12px;
        }
        
        .process-btn:hover {
            background: #36a420;
        }
        
        .process-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .original-section {
            margin: 15px 0;
            text-align: center;
        }
        
        .original-section h2 {
            color: #333;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            max-width: 100%;
            height: auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .results-section {
            margin-top: 20px;
        }
        
        .results-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3b5998;
        }
        
        .filter-category {
            margin-bottom: 20px;
        }
        
        .filter-category h3 {
            color: #4267b2;
            margin-bottom: 12px;
            font-size: 16px;
        }
        
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .filter-result {
            background: #f6f7f9;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .filter-result h4 {
            color: #555;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .filter-result canvas {
            max-width: 100%;
            height: auto;
        }
        
        .filter-description {
            margin-top: 8px;
            padding: 8px;
            background: white;
            border-radius: 5px;
            font-size: 12px;
            color: #666;
            text-align: left;
            line-height: 1.4;
        }
        
        .filter-description canvas {
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .filter-description strong {
            color: #333;
        }
        
        .post-button {
            background: #42b72a;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: background 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .post-button:hover {
            background: #36a420;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .post-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .feed-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 3px solid #3b5998;
        }
        
        .feed-section h2 {
            color: #3b5998;
            margin-bottom: 20px;
            font-size: 20px;
        }
        
        .post-item {
            background: #f6f7f9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
        }
        
        .post-avatar {
            width: 35px;
            height: 35px;
            background: #4267b2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
        }
        
        .post-info {
            flex: 1;
        }
        
        .post-author {
            font-weight: bold;
            color: #3b5998;
            font-size: 14px;
        }
        
        .post-time {
            color: #90949c;
            font-size: 11px;
        }
        
        .delete-post-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.3s;
        }
        
        .delete-post-btn:hover {
            background: #c0392b;
        }
        
        .post-content {
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .post-images {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }
        
        .post-images canvas, .post-images img {
            width: 100%;
            height: auto;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .interpretation-text {
            background: white;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            border-left: 4px solid #4267b2;
        }
        
        .interpretation-text h4 {
            color: #4267b2;
            margin-bottom: 8px;
            font-size: 15px;
        }
        
        .interpretation-text p {
            color: #333;
            line-height: 1.5;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .no-posts {
            text-align: center;
            padding: 30px;
            color: #666;
            font-style: italic;
        }
        
        .post-actions {
            background: white;
            border-top: 1px solid #e5e5e5;
            padding: 12px;
            margin-top: 12px;
            border-radius: 0 0 8px 8px;
        }
        
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e5e5e5;
        }
        
        .action-btn {
            background: white;
            border: 1px solid #cbd0d8;
            padding: 6px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s;
            flex: 1;
            justify-content: center;
        }
        
        .action-btn:hover {
            background: #e7f3ff;
            border-color: #4267b2;
        }
        
        .action-btn.liked {
            background: #4267b2;
            color: white;
            border-color: #4267b2;
        }
        
        .action-icon {
            font-size: 16px;
        }
        
        .comment-form {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .comment-input {
            flex: 1;
            border: 1px solid #cbd0d8;
            border-radius: 20px;
            padding: 8px 12px;
            font-size: 13px;
            outline: none;
        }
        
        .comment-input:focus {
            border-color: #4267b2;
        }
        
        .comment-submit-btn {
            background: #4267b2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .comment-submit-btn:hover {
            background: #365899;
        }
        
        .comments-list {
            margin-top: 12px;
        }
        
        .comment {
            background: #f0f2f5;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            position: relative;
        }
        
        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .comment-author {
            font-weight: bold;
            color: #3b5998;
            font-size: 12px;
        }
        
        .delete-comment-btn {
            background: transparent;
            border: none;
            color: #90949c;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
            transition: color 0.3s;
        }
        
        .delete-comment-btn:hover {
            color: #e74c3c;
        }
        
        .comment-text {
            color: #333;
            font-size: 13px;
            margin-bottom: 4px;
        }
        
        .comment-time {
            color: #90949c;
            font-size: 10px;
        }
        
        .loading {
            text-align: center;
            padding: 15px;
            color: #666;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4267b2;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            animation: spin 1s linear infinite;
            margin: 15px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        .info-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        
        .info-box p {
            color: #155724;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .format-support {
            background: #d1ecf1;
            border-left: 4px solid #0c5460;
            padding: 10px;
            margin-top: 8px;
            border-radius: 4px;
        }
        
        .format-support p {
            color: #0c5460;
            font-size: 12px;
            margin: 0;
        }
        
        .optimization-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin-top: 8px;
            border-radius: 4px;
        }
        
        .optimization-info p {
            color: #856404;
            font-size: 12px;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🖼️ Mejoramiento de Imágenes con Transformada de Fourier</h1>
            <p>Algoritmos de mejoramiento en el dominio de Fourier</p>
        </div>
        
        <!-- Información Institucional -->
        <div class="institution-info">
            <div class="institution-header">
                <h2>🎓 Maestría en Inteligencia Artificial Aplicada</h2>
                <h3>Tecnológico de Monterrey</h3>
            </div>
            
            <div class="badges">
                <span class="badge">Tecnológico de Monterrey</span>
                <span class="badge course">Computer Vision</span>
                <span class="badge activity">Actividad 5.4 - Google Colab</span>
            </div>
            
            <div class="professors">
                <h4>👨‍🏫 Profesores</h4>
                <ul>
                    <li><strong>Profesor Titular:</strong> Dr. Gilberto Ochoa Ruiz</li>
                    <li><strong>Profesor Asistente:</strong> MIP Ma. del Refugio Melendez Alfaro</li>
                    <li><strong>Profesor Tutor:</strong> M. en C. Jose Angel Martinez Navarro</li>
                </ul>
            </div>
            
            <div style="text-align: center; margin-top: 12px;">
                <p style="font-size: 13px;"><strong>📌 Título:</strong> Algoritmos de mejoramiento de imágenes en el dominio de Fourier</p>
                <p style="font-size: 13px;"><strong>📅 Fecha de entrega:</strong> Octubre 12, 2025 a las 23:59</p>
            </div>
        </div>
        
        <!-- Sección del Equipo -->
        <div class="team-section">
            <h3>👥 Team 13 - Nuestro Equipo</h3>
            <div class="team-grid">
                <div class="team-member">
                    <img src="https://iili.io/KuvsGKx.png" alt="Javier Augusto Rebull Saucedo">
                    <h4>Javier Augusto Rebull Saucedo</h4>
                    <p class="matricula">A01795838</p>
                    <p class="role">🎓 MNA Student</p>
                </div>
                
                <div class="team-member">
                    <img src="https://iili.io/KuvP4gp.png" alt="Juan Carlos Pérez Nava">
                    <h4>Juan Carlos Pérez Nava</h4>
                    <p class="matricula">A01795941</p>
                    <p class="role">🎓 MNA Student</p>
                </div>
                
                <div class="team-member">
                    <img src="https://iili.io/KuvLaJp.png" alt="Luis Gerardo Sánchez Salazar">
                    <h4>Luis Gerardo Sánchez Salazar</h4>
                    <p class="matricula">A01232963</p>
                    <p class="role">🎓 MNA Student</p>
                </div>
                
                <div class="team-member">
                    <img src="https://iili.io/KuvQx24.png" alt="Oscar Enrique García García">
                    <h4>Oscar Enrique García García</h4>
                    <p class="matricula">A01016093</p>
                    <p class="role">🎓 MNA Student</p>
                </div>
            </div>
        </div>
        
        <div id="firebaseStatus" class="firebase-status">
            🔄 Conectando a Firebase...
        </div>
        
        <div class="content">
            <div class="info-box">
                <p><strong>🌐 Feed Global con Firebase Storage:</strong> ¡Todos los visitantes ven las mismas publicaciones! Las imágenes se almacenan en Firebase Storage (5GB gratis + Plan Blaze) y los metadatos en Firestore. ¡Puedes dar like, comentar y eliminar posts!</p>
            </div>
            
            <div class="upload-section">
                <h3>📤 Subir Imagen</h3>
                <input type="file" id="imageUpload" accept="image/*,.heic,.HEIC,.heif,.HEIF,.dng,.DNG">
                <label for="imageUpload" class="upload-btn">Seleccionar Imagen</label>
                <p id="fileName" style="margin-top: 8px; color: #666; font-size: 13px;"></p>
                <div class="format-support">
                    <p>✅ Formatos soportados: JPG, PNG, WEBP, HEIC (iPhone), DNG (RAW), y más</p>
                </div>
                <div class="optimization-info">
                    <p>⚡ Las imágenes se suben a Firebase Storage con compresión inteligente</p>
                </div>
                <button id="processBtn" class="process-btn" onclick="processImage()" disabled>🔬 Procesar con Filtros de Fourier</button>
            </div>
            
            <div id="originalSection" class="original-section hidden">
                <h2>📷 Imagen Original (Escala de Grises)</h2>
                <canvas id="originalCanvas"></canvas>
            </div>
            
            <div id="loadingSection" class="loading hidden">
                <div class="spinner"></div>
                <p id="loadingText">Procesando imagen con filtros de Fourier...</p>
            </div>
            
            <div id="resultsSection" class="results-section hidden">
                <h2>✨ Resultados del Procesamiento</h2>
                
                <div class="filter-category">
                    <h3>🔽 Filtros Pasa-Bajas (Suavizado - Eliminan alta frecuencia/detalles)</h3>
                    <div class="filters-grid">
                        <div class="filter-result">
                            <h4>Ideal</h4>
                            <canvas id="lpIdeal"></canvas>
                            <div class="filter-description">
                                <strong>Parámetros:</strong> D0=<span id="param_lpIdeal_D0">50</span><br>
                                <strong>Máscara:</strong><br>
                                <canvas id="mask_lpIdeal" style="width: 100px; height: 100px; margin: 5px auto; display: block;"></canvas>
                                <strong>Efecto:</strong> Corte abrupto en frecuencia. Suaviza pero puede crear efecto "ringing" (anillos).
                            </div>
                        </div>
                        <div class="filter-result">
                            <h4>Butterworth (n=2)</h4>
                            <canvas id="lpButterworth"></canvas>
                            <div class="filter-description">
                                <strong>Parámetros:</strong> D0=<span id="param_lpButterworth_D0">50</span>, n=<span id="param_lpButterworth_n">2</span><br>
                                <strong>Máscara:</strong><br>
                                <canvas id="mask_lpButterworth" style="width: 100px; height: 100px; margin: 5px auto; display: block;"></canvas>
                                <strong>Efecto:</strong> Transición suave. Reduce ruido sin ringing excesivo. Más natural.
                            </div>
                        </div>
                        <div class="filter-result">
                            <h4>Gaussian</h4>
                            <canvas id="lpGaussian"></canvas>
                            <div class="filter-description">
                                <strong>Parámetros:</strong> D0=<span id="param_lpGaussian_D0">50</span><br>
                                <strong>Máscara:</strong><br>
                                <canvas id="mask_lpGaussian" style="width: 100px; height: 100px; margin: 5px auto; display: block;"></canvas>
                                <strong>Efecto:</strong> Transición muy suave. El más natural. Tipo "blur" clásico.
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="filter-category">
                    <h3>🔼 Filtros Pasa-Altas (Realce de bordes - Eliminan baja frecuencia)</h3>
                    <div style="background: #e7f3ff; padding: 12px; border-radius: 6px; margin-bottom: 12px; border-left: 4px solid #4267b2;">
                        <strong style="color: #1F497D;">⚙️ Amplificación de Bordes:</strong>
                        <input type="range" id="gainSlider" min="1" max="30" value="15" step="1" 
                               style="width: 200px; vertical-align: middle; margin: 0 10px;"
                               onchange="updateGainValue(this.value)">
                        <span id="gainValue" style="font-weight: bold; color: #4267b2;">15×</span>
                        <button onclick="reprocessWithNewGain()" 
                                style="background: #4267b2; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-left: 10px; cursor: pointer; font-size: 12px;">
                            🔄 Aplicar
                        </button>
                        <p style="margin: 8px 0 0 0; font-size: 11px; color: #666;">
                            Ajusta la intensidad de los bordes en los filtros pasa-altas. Valores más altos = bordes más visibles.
                        </p>
                    </div>
                    <div class="filters-grid">
                        <div class="filter-result">
                            <h4>Ideal</h4>
                            <canvas id="hpIdeal"></canvas>
                            <div class="filter-description">
                                <strong>Parámetros:</strong> D0=<span id="param_hpIdeal_D0">50</span><br>
                                <strong>Máscara:</strong><br>
                                <canvas id="mask_hpIdeal" style="width: 100px; height: 100px; margin: 5px auto; display: block;"></canvas>
                                <strong>Efecto:</strong> Resalta bordes abruptamente. Puede verse "artificial".
                            </div>
                        </div>
                        <div class="filter-result">
                            <h4>Butterworth (n=2)</h4>
                            <canvas id="hpButterworth"></canvas>
                            <div class="filter-description">
                                <strong>Parámetros:</strong> D0=<span id="param_hpButterworth_D0">50</span>, n=<span id="param_hpButterworth_n">2</span><br>
                                <strong>Máscara:</strong><br>
                                <canvas id="mask_hpButterworth" style="width: 100px; height: 100px; margin: 5px auto; display: block;"></canvas>
                                <strong>Efecto:</strong> Realza bordes suavemente. Buen balance entre detalle y naturalidad.
                            </div>
                        </div>
                        <div class="filter-result">
                            <h4>Gaussian</h4>
                            <canvas id="hpGaussian"></canvas>
                            <div class="filter-description">
                                <strong>Parámetros:</strong> D0=<span id="param_hpGaussian_D0">50</span><br>
                                <strong>Máscara:</strong><br>
                                <canvas id="mask_hpGaussian" style="width: 100px; height: 100px; margin: 5px auto; display: block;"></canvas>
                                <strong>Efecto:</strong> Realce de bordes muy gradual. Detecta contornos sutiles.
                            </div>
                        </div>
                    </div>
                </div>
                
                <button id="postButton" class="post-button" onclick="publishToFeed()">📤 Publicar Resultado en Feed Global</button>
            </div>
            
            <div class="feed-section" id="feedSection">
                <h2>🌐 Feed Global de Procesamiento</h2>
                <div id="feedContainer">
                    <div class="no-posts">
                        <div class="spinner"></div>
                        <p>Cargando publicaciones...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK v9 modular -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, deleteDoc, doc, updateDoc, arrayUnion, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getStorage, ref, uploadString, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

        // Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyD3HXas_ZlSBHkcgqj58gtvOaDIE751skg",
          authDomain: "fourier-vision-9243d.firebaseapp.com",
          projectId: "fourier-vision-9243d",
          storageBucket: "fourier-vision-9243d.firebasestorage.app",
          messagingSenderId: "713813028117",
          appId: "1:713813028117:web:bb7e8bdf989a7966498d1c",
          measurementId: "G-24BGNP617J"
        };

        // Inicializar Firebase
        let db, storage, firebaseInitialized = false;

        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            storage = getStorage(app);
            firebaseInitialized = true;
            updateFirebaseStatus(true);
            console.log('✅ Firebase conectado correctamente (Firestore + Storage)');
            
            // Hacer disponibles globalmente
            window.db = db;
            window.storage = storage;
            window.firebaseInitialized = firebaseInitialized;
            window.firebaseModules = { collection, addDoc, query, orderBy, limit, onSnapshot, deleteDoc, doc, updateDoc, arrayUnion, serverTimestamp, ref, uploadString, getDownloadURL, deleteObject };
            
            // Cargar feed después de inicializar
            loadFeed();
        } catch (error) {
            console.error('❌ Error al conectar Firebase:', error);
            updateFirebaseStatus(false);
        }

        function updateFirebaseStatus(connected) {
            const statusDiv = document.getElementById('firebaseStatus');
            if (connected) {
                statusDiv.textContent = '✅ Conectado a Firebase - Firestore + Storage (Plan Blaze) Activo';
                statusDiv.className = 'firebase-status';
            } else {
                statusDiv.textContent = '❌ Error de conexión - Verifica tu configuración de Firebase';
                statusDiv.className = 'firebase-status disconnected';
            }
        }
        
        window.updateFirebaseStatus = updateFirebaseStatus;
    </script>
    
    <!-- HEIC support -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>

    <script>
        // ========================================
        // VARIABLES GLOBALES
        // ========================================
        let uploadedImage = null;
        let currentResults = {};
        let currentMasks = {};      // Para almacenar las máscaras de frecuencia
        let currentParams = {};     // Para almacenar parámetros (D0, n)
        let feedPosts = [];
        let userLikes = new Set();
        
        // Tamaños optimizados para Firebase Storage (Plan Blaze)
        // Storage puede manejar archivos más grandes sin problema
        const MAX_DISPLAY_SIZE = 500;   // Para mostrar en pantalla
        const MAX_STORAGE_SIZE = 400;   // Para guardar en Storage
        const MAX_PROCESS_SIZE = 256;   // Para procesamiento FFT
        const JPEG_QUALITY = 0.85;      // Mejor calidad ahora que usamos Storage
        
        let CURRENT_GAIN = 15.0;  // Valor inicial de amplificación
        let lastGrayData = null;  // Guardar datos en escala de grises para reprocesar
        let lastWidth = 0;
        let lastHeight = 0;
        
        function updateGainValue(value) {
            document.getElementById('gainValue').textContent = value + '×';
            CURRENT_GAIN = parseFloat(value);
        }
        
        function reprocessWithNewGain() {
            if (!lastGrayData || lastWidth === 0 || lastHeight === 0) {
                alert('Primero procesa una imagen antes de ajustar la amplificación.');
                return;
            }
            
            // Reprocesar solo los filtros pasa-altas con el nuevo GAIN
            const D0 = 50;
            const n = 2;
            
            applyFilter(lastGrayData, lastWidth, lastHeight, 'ideal', false, D0, n, 'hpIdeal');
            applyFilter(lastGrayData, lastWidth, lastHeight, 'butterworth', false, D0, n, 'hpButterworth');
            applyFilter(lastGrayData, lastWidth, lastHeight, 'gaussian', false, D0, n, 'hpGaussian');
        }
        
        // ========================================
        // MANEJO DE ARCHIVOS HEIC Y DNG
        // ========================================
        
        async function convertHEICtoJPEG(file) {
            try {
                console.log('🔄 Convirtiendo archivo HEIC...');
                
                // Verificar que heic2any esté disponible
                if (typeof heic2any === 'undefined') {
                    throw new Error('La librería heic2any no está cargada. Recarga la página.');
                }
                
                const convertedBlob = await heic2any({
                    blob: file,
                    toType: "image/jpeg",
                    quality: 0.92
                });
                
                console.log('✅ HEIC convertido exitosamente');
                return new File([convertedBlob], file.name.replace(/\.(heic|heif)$/i, '.jpg'), { 
                    type: 'image/jpeg' 
                });
            } catch (error) {
                console.error('❌ Error converting HEIC:', error);
                throw new Error('No se pudo convertir el archivo HEIC. Error: ' + error.message);
            }
        }
        
        async function convertDNGtoJPEG(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        canvas.toBlob((blob) => {
                            resolve(new File([blob], file.name.replace(/\.dng$/i, '.jpg'), { 
                                type: 'image/jpeg' 
                            }));
                        }, 'image/jpeg', 0.92);
                    };
                    img.onerror = () => {
                        reject(new Error('El archivo DNG no se pudo procesar. Intenta convertirlo a JPG primero.'));
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    reject(new Error('Error al leer el archivo DNG'));
                };
                reader.readAsDataURL(file);
            });
        }
        
        // ========================================
        // OPTIMIZACIÓN DE IMÁGENES
        // ========================================
        
        function resizeImage(img, maxSize, quality = 0.9) {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            if (width > maxSize || height > maxSize) {
                const ratio = Math.min(maxSize / width, maxSize / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            return canvas.toDataURL('image/jpeg', quality);
        }
        
        // File upload handler
        document.getElementById('imageUpload').addEventListener('change', async function(e) {
            let file = e.target.files[0];
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            const fileNameDisplay = document.getElementById('fileName');
            
            try {
                if (fileName.endsWith('.heic') || fileName.endsWith('.heif')) {
                    fileNameDisplay.textContent = `🔄 Convirtiendo HEIC: ${file.name}...`;
                    fileNameDisplay.style.color = '#4267b2';
                    
                    file = await convertHEICtoJPEG(file);
                    
                    fileNameDisplay.textContent = `✅ Convertido: ${file.name}`;
                    fileNameDisplay.style.color = '#28a745';
                } else if (fileName.endsWith('.dng')) {
                    fileNameDisplay.textContent = `🔄 Procesando DNG: ${file.name}...`;
                    fileNameDisplay.style.color = '#4267b2';
                    
                    file = await convertDNGtoJPEG(file);
                    
                    fileNameDisplay.textContent = `✅ Procesado: ${file.name}`;
                    fileNameDisplay.style.color = '#28a745';
                } else {
                    fileNameDisplay.textContent = `📄 ${file.name}`;
                    fileNameDisplay.style.color = '#666';
                }
                
                document.getElementById('processBtn').disabled = false;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        uploadedImage = img;
                        displayOriginalImage(img);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                
            } catch (error) {
                console.error('Error procesando archivo:', error);
                alert(error.message);
                fileNameDisplay.textContent = `❌ Error: ${error.message}`;
                fileNameDisplay.style.color = '#e74c3c';
                document.getElementById('processBtn').disabled = true;
            }
        });
        
        function displayOriginalImage(img) {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            let width = img.width;
            let height = img.height;
            
            // Tamaño para display
            if (width > MAX_DISPLAY_SIZE || height > MAX_DISPLAY_SIZE) {
                const ratio = Math.min(MAX_DISPLAY_SIZE / width, MAX_DISPLAY_SIZE / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Dibujar imagen en escala de grises
            ctx.drawImage(img, 0, 0, width, height);
            
            // Convertir a escala de grises
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Guardar versión optimizada para storage
            currentResults['original'] = resizeImage(img, MAX_STORAGE_SIZE, JPEG_QUALITY);
            
            document.getElementById('originalSection').classList.remove('hidden');
        }
        
        function processImage() {
            if (!uploadedImage) {
                alert('Por favor, primero suba una imagen.');
                return;
            }
            
            document.getElementById('loadingSection').classList.remove('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            
            setTimeout(() => {
                try {
                    applyFourierFilters(uploadedImage);
                    document.getElementById('loadingSection').classList.add('hidden');
                    document.getElementById('resultsSection').classList.remove('hidden');
                } catch (error) {
                    document.getElementById('loadingSection').classList.add('hidden');
                    alert('Error al procesar la imagen: ' + error.message);
                    console.error(error);
                }
            }, 100);
        }
        
        function applyFourierFilters(img) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            let width = img.width;
            let height = img.height;
            
            // Reducir tamaño para procesamiento FFT
            if (width > MAX_PROCESS_SIZE || height > MAX_PROCESS_SIZE) {
                const ratio = Math.min(MAX_PROCESS_SIZE / width, MAX_PROCESS_SIZE / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }
            
            width = Math.max(32, width);
            height = Math.max(32, height);
            
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.drawImage(img, 0, 0, width, height);
            
            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const grayData = new Float32Array(width * height);
            for (let i = 0; i < width * height; i++) {
                if (i * 4 + 2 < data.length) {
                    const r = data[i * 4];
                    const g = data[i * 4 + 1];
                    const b = data[i * 4 + 2];
                    grayData[i] = 0.299 * r + 0.587 * g + 0.114 * b;
                }
            }
            
            // Guardar para reprocesamiento con diferente GAIN
            lastGrayData = new Float32Array(grayData);
            lastWidth = width;
            lastHeight = height;
            
            const D0 = 50;  // Frecuencia de corte (igual que en Python)
            const n = 2;    // Orden del filtro Butterworth
            
            applyFilter(grayData, width, height, 'ideal', true, D0, n, 'lpIdeal');
            applyFilter(grayData, width, height, 'butterworth', true, D0, n, 'lpButterworth');
            applyFilter(grayData, width, height, 'gaussian', true, D0, n, 'lpGaussian');
            
            applyFilter(grayData, width, height, 'ideal', false, D0, n, 'hpIdeal');
            applyFilter(grayData, width, height, 'butterworth', false, D0, n, 'hpButterworth');
            applyFilter(grayData, width, height, 'gaussian', false, D0, n, 'hpGaussian');
        }
        
        function applyFilter(grayData, width, height, filterType, isLowPass, D0, n, canvasId) {
            try {
                const newWidth = Math.pow(2, Math.ceil(Math.log2(width)));
                const newHeight = Math.pow(2, Math.ceil(Math.log2(height)));
                
                let paddedData = grayData;
                let actualWidth = width;
                let actualHeight = height;
                
                if (newWidth !== width || newHeight !== height) {
                    paddedData = new Float32Array(newWidth * newHeight);
                    paddedData.fill(0);
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            paddedData[y * newWidth + x] = grayData[y * width + x];
                        }
                    }
                    actualWidth = newWidth;
                    actualHeight = newHeight;
                }
                
                // 1. Aplicar FFT 2D
                const fftResult = fft2d(paddedData, actualWidth, actualHeight);
                
                // 2. Aplicar fftshift (centrar el espectro)
                const fftShifted = fftshift2d(fftResult, actualWidth, actualHeight);
                
                // 3. Crear y aplicar el filtro
                const filter = createFrequencyFilter(actualWidth, actualHeight, filterType, isLowPass, D0, n);
                
                // Guardar la máscara para visualización
                const maskCanvasId = canvasId.replace('lp', 'mask_lp').replace('hp', 'mask_hp');
                displayMask(filter, actualWidth, actualHeight, maskCanvasId);
                
                // Guardar parámetros
                currentParams[canvasId] = { D0, n, filterType, isLowPass };
                
                for (let i = 0; i < actualWidth * actualHeight; i++) {
                    fftShifted.real[i] *= filter[i];
                    fftShifted.imag[i] *= filter[i];
                }
                
                // 4. Aplicar ifftshift (descentrar antes de IFFT)
                const fftUnshifted = ifftshift2d(fftShifted, actualWidth, actualHeight);
                
                // 5. Aplicar IFFT 2D
                const result = ifft2d(fftUnshifted, actualWidth, actualHeight);
                
                // 6. Recortar al tamaño original
                const croppedResult = new Float32Array(width * height);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        croppedResult[y * width + x] = result[y * actualWidth + x];
                    }
                }
                
                displayResult(croppedResult, width, height, canvasId);
            } catch (error) {
                console.error(`Error in ${canvasId}:`, error);
            }
        }
        
        function fftshift2d(fftData, width, height) {
            // Centrar el espectro de frecuencias (como np.fft.fftshift)
            const shifted = {
                real: new Float32Array(width * height),
                imag: new Float32Array(width * height)
            };
            
            const halfWidth = Math.floor(width / 2);
            const halfHeight = Math.floor(height / 2);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const newY = (y + halfHeight) % height;
                    const newX = (x + halfWidth) % width;
                    const oldIdx = y * width + x;
                    const newIdx = newY * width + newX;
                    shifted.real[newIdx] = fftData.real[oldIdx];
                    shifted.imag[newIdx] = fftData.imag[oldIdx];
                }
            }
            
            return shifted;
        }
        
        function ifftshift2d(fftData, width, height) {
            // Descentrar el espectro de frecuencias (como np.fft.ifftshift)
            const unshifted = {
                real: new Float32Array(width * height),
                imag: new Float32Array(width * height)
            };
            
            const halfWidth = Math.ceil(width / 2);
            const halfHeight = Math.ceil(height / 2);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const newY = (y + halfHeight) % height;
                    const newX = (x + halfWidth) % width;
                    const oldIdx = y * width + x;
                    const newIdx = newY * width + newX;
                    unshifted.real[newIdx] = fftData.real[oldIdx];
                    unshifted.imag[newIdx] = fftData.imag[oldIdx];
                }
            }
            
            return unshifted;
        }
        
        function createFrequencyFilter(width, height, type, isLowPass, D0, n) {
            const filter = new Float32Array(width * height);
            
            // Centro del espectro (como en el código Python)
            const crow = Math.floor(height / 2);
            const ccol = Math.floor(width / 2);
            
            for (let u = 0; u < height; u++) {
                for (let v = 0; v < width; v++) {
                    // Calcular distancia desde el centro del espectro
                    const D = Math.sqrt((v - ccol) ** 2 + (u - crow) ** 2);
                    
                    let H;
                    if (type === 'ideal') {
                        // Filtro Ideal: 1 si D <= D0, sino 0
                        H = D <= D0 ? 1 : 0;
                    } else if (type === 'butterworth') {
                        // Filtro Butterworth
                        H = 1 / (1 + Math.pow(D / D0, 2 * n));
                    } else if (type === 'gaussian') {
                        // Filtro Gaussiano
                        H = Math.exp(-(D * D) / (2 * D0 * D0));
                    }
                    
                    // Para filtros pasa-altas: H_highpass = 1 - H_lowpass
                    if (!isLowPass) {
                        H = 1 - H;
                    }
                    
                    filter[u * width + v] = H;
                }
            }
            
            return filter;
        }
        
        function fft2d(data, width, height) {
            const real = new Float32Array(data);
            const imag = new Float32Array(width * height);
            
            for (let y = 0; y < height; y++) {
                const rowReal = new Float32Array(width);
                const rowImag = new Float32Array(width);
                
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (idx < real.length) {
                        rowReal[x] = real[idx];
                        rowImag[x] = imag[idx];
                    }
                }
                
                const fftRow = fft(rowReal, rowImag);
                
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (idx < real.length && x < fftRow.real.length) {
                        real[idx] = fftRow.real[x];
                        imag[idx] = fftRow.imag[x];
                    }
                }
            }
            
            for (let x = 0; x < width; x++) {
                const colReal = new Float32Array(height);
                const colImag = new Float32Array(height);
                
                for (let y = 0; y < height; y++) {
                    const idx = y * width + x;
                    if (idx < real.length) {
                        colReal[y] = real[idx];
                        colImag[y] = imag[idx];
                    }
                }
                
                const fftCol = fft(colReal, colImag);
                
                for (let y = 0; y < height; y++) {
                    const idx = y * width + x;
                    if (idx < real.length && y < fftCol.real.length) {
                        real[idx] = fftCol.real[y];
                        imag[idx] = fftCol.imag[y];
                    }
                }
            }
            
            return { real, imag };
        }
        
        function ifft2d(fftData, width, height) {
            const real = new Float32Array(fftData.real);
            const imag = new Float32Array(fftData.imag);
            
            for (let y = 0; y < height; y++) {
                const rowReal = new Float32Array(width);
                const rowImag = new Float32Array(width);
                
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (idx < real.length) {
                        rowReal[x] = real[idx];
                        rowImag[x] = imag[idx];
                    }
                }
                
                const ifftRow = ifft(rowReal, rowImag);
                
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (idx < real.length && x < ifftRow.real.length) {
                        real[idx] = ifftRow.real[x];
                        imag[idx] = ifftRow.imag[x];
                    }
                }
            }
            
            for (let x = 0; x < width; x++) {
                const colReal = new Float32Array(height);
                const colImag = new Float32Array(height);
                
                for (let y = 0; y < height; y++) {
                    const idx = y * width + x;
                    if (idx < real.length) {
                        colReal[y] = real[idx];
                        colImag[y] = imag[idx];
                    }
                }
                
                const ifftCol = ifft(colReal, colImag);
                
                for (let y = 0; y < height; y++) {
                    const idx = y * width + x;
                    if (idx < real.length && y < ifftCol.real.length) {
                        real[idx] = ifftCol.real[y];
                    }
                }
            }
            
            return real;
        }
        
        function fft(real, imag) {
            const n = real.length;
            if (n <= 1) return { real, imag };
            
            const n2 = Math.pow(2, Math.ceil(Math.log2(n)));
            if (n !== n2) {
                const paddedReal = new Float32Array(n2);
                const paddedImag = new Float32Array(n2);
                paddedReal.set(real);
                paddedImag.set(imag);
                return fft(paddedReal, paddedImag);
            }
            
            const outReal = new Float32Array(n);
            const outImag = new Float32Array(n);
            for (let i = 0; i < n; i++) {
                const rev = bitReverse(i, Math.log2(n));
                outReal[i] = real[rev];
                outImag[i] = imag[rev];
            }
            
            for (let size = 2; size <= n; size *= 2) {
                const halfSize = size / 2;
                const step = 2 * Math.PI / size;
                for (let i = 0; i < n; i += size) {
                    for (let j = 0; j < halfSize; j++) {
                        const angle = step * j;
                        const wReal = Math.cos(angle);
                        const wImag = -Math.sin(angle);
                        
                        const tReal = wReal * outReal[i + j + halfSize] - wImag * outImag[i + j + halfSize];
                        const tImag = wReal * outImag[i + j + halfSize] + wImag * outReal[i + j + halfSize];
                        
                        outReal[i + j + halfSize] = outReal[i + j] - tReal;
                        outImag[i + j + halfSize] = outImag[i + j] - tImag;
                        outReal[i + j] += tReal;
                        outImag[i + j] += tImag;
                    }
                }
            }
            
            return { real: outReal, imag: outImag };
        }
        
        function ifft(real, imag) {
            const n = real.length;
            
            const conjImag = new Float32Array(n);
            for (let i = 0; i < n; i++) {
                conjImag[i] = -imag[i];
            }
            
            const result = fft(real, conjImag);
            
            for (let i = 0; i < n; i++) {
                result.real[i] /= n;
                result.imag[i] = -result.imag[i] / n;
            }
            
            return result;
        }
        
        function bitReverse(x, bits) {
            let result = 0;
            for (let i = 0; i < bits; i++) {
                result = (result << 1) | (x & 1);
                x >>= 1;
            }
            return result;
        }
        
        function displayMask(filter, width, height, canvasId) {
            try {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return; // Canvas de máscara opcional
                
                // Mostrar máscara a tamaño reducido
                const maskSize = 150;
                canvas.width = maskSize;
                canvas.height = maskSize;
                const ctx = canvas.getContext('2d');
                
                // Crear imagen de la máscara
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(width, height);
                
                for (let i = 0; i < width * height; i++) {
                    const value = Math.round(filter[i] * 255);
                    const idx = i * 4;
                    imageData.data[idx] = value;
                    imageData.data[idx + 1] = value;
                    imageData.data[idx + 2] = value;
                    imageData.data[idx + 3] = 255;
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                
                // Escalar al tamaño de visualización
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(tempCanvas, 0, 0, maskSize, maskSize);
                
                // Guardar máscara
                currentMasks[canvasId] = tempCanvas.toDataURL('image/jpeg', 0.8);
                
            } catch (error) {
                console.error(`Error displaying mask ${canvasId}:`, error);
            }
        }
        
        function displayResult(data, width, height, canvasId) {
            try {
                for (let i = 0; i < data.length; i++) {
                    if (!isFinite(data[i])) {
                        data[i] = 0;
                    }
                }
                
                // Detectar si es un filtro pasa-altas (por el nombre del canvas)
                const isHighPass = canvasId.startsWith('hp');
                
                const canvas = document.getElementById(canvasId);
                
                // Escalar para mejor visualización (Storage permite mejor calidad)
                const displayScale = 1.6;
                const displayWidth = width * displayScale;
                const displayHeight = height * displayScale;
                
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                const ctx = canvas.getContext('2d');
                
                // Crear imagen temporal en tamaño original
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(width, height);
                
                if (isHighPass) {
                    // Para filtros pasa-altas: usar el GAIN actual ajustable
                    const GAIN = CURRENT_GAIN;  // Usar valor del slider
                    
                    // Amplificar valores
                    const amplified = new Float32Array(data.length);
                    for (let i = 0; i < data.length; i++) {
                        amplified[i] = data[i] * GAIN;
                    }
                    
                    // Encontrar percentiles para mejor contraste (ignorar outliers)
                    const sorted = Array.from(amplified).sort((a, b) => a - b);
                    const p2 = sorted[Math.floor(sorted.length * 0.02)];  // Percentil 2%
                    const p98 = sorted[Math.floor(sorted.length * 0.98)]; // Percentil 98%
                    
                    const range = p98 - p2;
                    
                    for (let i = 0; i < width * height; i++) {
                        let value;
                        if (range === 0) {
                            value = 128;
                        } else {
                            // Normalizar usando percentiles para mejor contraste
                            value = ((amplified[i] - p2) / range) * 255;
                            // Clip a rango válido
                            value = Math.max(0, Math.min(255, Math.round(value)));
                        }
                        
                        const idx = i * 4;
                        if (idx + 3 < imageData.data.length) {
                            imageData.data[idx] = value;
                            imageData.data[idx + 1] = value;
                            imageData.data[idx + 2] = value;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                } else {
                    // Para filtros pasa-bajas: normalización estándar [0, 255]
                    let min = Infinity;
                    let max = -Infinity;
                    for (let i = 0; i < data.length; i++) {
                        if (data[i] < min) min = data[i];
                        if (data[i] > max) max = data[i];
                    }
                    
                    const range = max - min;
                    
                    for (let i = 0; i < width * height; i++) {
                        const normalized = range === 0 ? 0 : ((data[i] - min) / range) * 255;
                        const value = Math.max(0, Math.min(255, Math.round(normalized)));
                        const idx = i * 4;
                        if (idx + 3 < imageData.data.length) {
                            imageData.data[idx] = value;
                            imageData.data[idx + 1] = value;
                            imageData.data[idx + 2] = value;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                
                // Escalar al canvas de visualización
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(tempCanvas, 0, 0, displayWidth, displayHeight);
                
                // Guardar versión con mejor compresión
                currentResults[canvasId] = tempCanvas.toDataURL('image/jpeg', JPEG_QUALITY);
                
                // Actualizar parámetros en el HTML
                const params = currentParams[canvasId];
                if (params) {
                    const d0Elem = document.getElementById(`param_${canvasId}_D0`);
                    const nElem = document.getElementById(`param_${canvasId}_n`);
                    if (d0Elem) d0Elem.textContent = params.D0;
                    if (nElem) nElem.textContent = params.n;
                }
                
            } catch (error) {
                console.error(`Error displaying ${canvasId}:`, error);
            }
        }
        
        // ========================================
        // FIREBASE STORAGE - SUBIDA DE IMÁGENES
        // ========================================
        
        async function uploadImageToStorage(dataUrl, path) {
            try {
                // Usar uploadString para subir data URLs directamente (evita problemas de CORS)
                const { ref, uploadString, getDownloadURL } = window.firebaseModules;
                const storageRef = ref(window.storage, path);
                
                console.log(`📤 Subiendo: ${path}`);
                
                // Subir como data_url directamente
                const snapshot = await uploadString(storageRef, dataUrl, 'data_url', {
                    contentType: 'image/jpeg',
                    cacheControl: 'public,max-age=31536000'
                });
                
                const downloadURL = await getDownloadURL(snapshot.ref);
                console.log(`✅ Subido: ${path}`);
                return downloadURL;
            } catch (error) {
                console.error('❌ Error uploading to storage:', error);
                throw error;
            }
        }
        
        async function publishToFeed() {
            if (!window.firebaseInitialized) {
                alert('Error: Firebase no está configurado.');
                return;
            }
            
            if (Object.keys(currentResults).length === 0) {
                alert('Primero procesa una imagen antes de publicar.');
                return;
            }
            
            try {
                document.getElementById('loadingText').textContent = '⚡ Subiendo imágenes a Storage...';
                document.getElementById('loadingSection').classList.remove('hidden');
                
                const timestamp = Date.now();
                const imageUrls = {};
                
                let uploadedCount = 0;
                const totalImages = Object.keys(currentResults).length;
                
                // Subir cada imagen a Firebase Storage
                for (const [key, dataUrl] of Object.entries(currentResults)) {
                    uploadedCount++;
                    document.getElementById('loadingText').textContent = 
                        `⚡ Subiendo imagen ${uploadedCount}/${totalImages} a Storage...`;
                    
                    const path = `posts/${timestamp}/${key}.jpg`;
                    imageUrls[key] = await uploadImageToStorage(dataUrl, path);
                }
                
                document.getElementById('loadingText').textContent = '💾 Guardando post en Firestore...';
                
                const { collection, addDoc, serverTimestamp } = window.firebaseModules;
                
                // Guardar solo las URLs en Firestore (mucho más eficiente)
                const post = {
                    timestamp: serverTimestamp(),
                    imageUrls: imageUrls,
                    createdAt: new Date().toISOString(),
                    likes: 0,
                    comments: []
                };
                
                await addDoc(collection(window.db, 'posts'), post);
                
                document.getElementById('loadingSection').classList.add('hidden');
                alert('¡Publicación guardada exitosamente en Storage! 🎉');
                
                document.getElementById('feedSection').scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                console.error('Error al publicar:', error);
                document.getElementById('loadingSection').classList.add('hidden');
                alert('Error al publicar: ' + error.message);
            }
        }
        
        // ========================================
        // SISTEMA DE LIKES
        // ========================================
        
        async function toggleLike(postId) {
            if (!window.firebaseInitialized) return;
            
            try {
                const { doc, updateDoc } = window.firebaseModules;
                const postRef = doc(window.db, 'posts', postId);
                
                const post = feedPosts.find(p => p.id === postId);
                if (!post) return;
                
                const currentLikes = post.likes || 0;
                
                if (userLikes.has(postId)) {
                    await updateDoc(postRef, {
                        likes: Math.max(0, currentLikes - 1)
                    });
                    userLikes.delete(postId);
                } else {
                    await updateDoc(postRef, {
                        likes: currentLikes + 1
                    });
                    userLikes.add(postId);
                }
            } catch (error) {
                console.error('Error toggling like:', error);
            }
        }
        
        // ========================================
        // SISTEMA DE COMENTARIOS
        // ========================================
        
        async function addComment(postId, commentText) {
            if (!window.firebaseInitialized || !commentText.trim()) return;
            
            try {
                const { doc, updateDoc, arrayUnion } = window.firebaseModules;
                const postRef = doc(window.db, 'posts', postId);
                const comment = {
                    id: Date.now().toString(),
                    text: commentText.trim(),
                    author: 'Usuario Anónimo',
                    timestamp: new Date().toISOString()
                };
                
                await updateDoc(postRef, {
                    comments: arrayUnion(comment)
                });
                
            } catch (error) {
                console.error('Error adding comment:', error);
            }
        }
        
        async function deleteComment(postId, commentId) {
            if (!window.firebaseInitialized) return;
            
            if (!confirm('¿Eliminar este comentario?')) return;
            
            try {
                const { doc, updateDoc } = window.firebaseModules;
                const postRef = doc(window.db, 'posts', postId);
                
                const post = feedPosts.find(p => p.id === postId);
                if (!post) return;
                
                const comments = post.comments || [];
                const updatedComments = comments.filter(c => c.id !== commentId);
                
                await updateDoc(postRef, {
                    comments: updatedComments
                });
                
            } catch (error) {
                console.error('Error deleting comment:', error);
            }
        }
        
        // ========================================
        // ELIMINAR POST Y SUS IMÁGENES DE STORAGE
        // ========================================
        
        async function deletePost(postId) {
            if (!window.firebaseInitialized) return;
            
            if (!confirm('¿Estás seguro de eliminar esta publicación? Esta acción no se puede deshacer.')) {
                return;
            }
            
            try {
                const { doc, deleteDoc, ref, deleteObject } = window.firebaseModules;
                
                const post = feedPosts.find(p => p.id === postId);
                if (!post) return;
                
                const imageUrls = post.imageUrls || {};
                
                console.log('🗑️ Eliminando imágenes de Storage...');
                
                // Eliminar cada imagen de Storage
                for (const [key, url] of Object.entries(imageUrls)) {
                    try {
                        // Extraer el path de la URL de Storage
                        const urlParts = url.split('/o/')[1].split('?')[0];
                        const path = decodeURIComponent(urlParts);
                        const storageRef = ref(window.storage, path);
                        await deleteObject(storageRef);
                        console.log(`✅ Eliminada imagen: ${key}`);
                    } catch (err) {
                        console.log(`⚠️ Error al eliminar imagen ${key}:`, err);
                    }
                }
                
                // Eliminar el documento de Firestore
                await deleteDoc(doc(window.db, 'posts', postId));
                
                console.log('✅ Post eliminado completamente');
                alert('Publicación eliminada exitosamente');
                
            } catch (error) {
                console.error('Error deleting post:', error);
                alert('Error al eliminar: ' + error.message);
            }
        }
        
        // ========================================
        // CARGAR Y RENDERIZAR FEED
        // ========================================
        
        function loadFeed() {
            if (!window.firebaseInitialized) {
                document.getElementById('feedContainer').innerHTML = `
                    <div class="no-posts">
                        <p style="color: #e74c3c;">⚠️ Firebase no está configurado.</p>
                    </div>
                `;
                return;
            }
            
            try {
                const { collection, query, orderBy, limit, onSnapshot } = window.firebaseModules;
                
                const q = query(
                    collection(window.db, 'posts'),
                    orderBy('timestamp', 'desc'),
                    limit(20)
                );
                
                onSnapshot(q, (snapshot) => {
                    feedPosts = [];
                    snapshot.forEach((doc) => {
                        feedPosts.push({ id: doc.id, ...doc.data() });
                    });
                    renderFeed();
                }, (error) => {
                    console.error('Error al cargar feed:', error);
                    document.getElementById('feedContainer').innerHTML = `
                        <div class="no-posts">
                            <p style="color: #e74c3c;">Error al cargar publicaciones: ${error.message}</p>
                        </div>
                    `;
                });
            } catch (error) {
                console.error('Error setting up feed listener:', error);
            }
        }
        
        function renderFeed() {
            const feedContainer = document.getElementById('feedContainer');
            
            if (feedPosts.length === 0) {
                feedContainer.innerHTML = '<div class="no-posts">No hay publicaciones aún. ¡Sé el primero en publicar!</div>';
                return;
            }
            
            feedContainer.innerHTML = '';
            
            const interpretationDiv = document.createElement('div');
            interpretationDiv.className = 'interpretation-text';
            interpretationDiv.style.marginBottom = '20px';
            const interpretation = generateInterpretation();
            interpretationDiv.innerHTML = `
                <h4>${interpretation.title}</h4>
                ${interpretation.sections.map(section => `
                    <p><strong>${section.title}:</strong> ${section.text}</p>
                `).join('')}
            `;
            feedContainer.appendChild(interpretationDiv);
            
            feedPosts.forEach((post, index) => {
                const postDiv = document.createElement('div');
                postDiv.className = 'post-item';
                
                let timeAgo = 'Hace un momento';
                if (post.timestamp) {
                    const postDate = post.timestamp.toDate ? post.timestamp.toDate() : new Date(post.createdAt);
                    timeAgo = getTimeAgo(postDate);
                }
                
                const likes = post.likes || 0;
                const comments = post.comments || [];
                const isLiked = userLikes.has(post.id);
                
                postDiv.innerHTML = `
                    <div class="post-header">
                        <div class="post-avatar">🌐</div>
                        <div class="post-info">
                            <div class="post-author">Team 13 - TEC</div>
                            <div class="post-time">${timeAgo}</div>
                        </div>
                        <button class="delete-post-btn" onclick="deletePost('${post.id}')">🗑️ Eliminar</button>
                    </div>
                    
                    <div class="post-content">
                        <p><strong>Procesamiento #${feedPosts.length - index}</strong> - Aplicación de 6 filtros de Fourier</p>
                    </div>
                    
                    <div class="post-images" style="max-width: 400px; margin: 0 auto;">
                        <div style="text-align: center;">
                            <strong style="font-size: 13px; color: #4267b2; display: block; margin-bottom: 5px;">📷 Original</strong>
                            <img src="${post.imageUrls.original}" loading="lazy" style="width: 100%; border-radius: 4px; border: 2px solid #4267b2; margin-top: 5px;">
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <strong style="color: #4267b2; margin-bottom: 8px; display: block; font-size: 14px;">🔽 Filtros Pasa-Bajas:</strong>
                        <div class="post-images">
                            <div style="text-align: center;">
                                <small style="color: #666; font-weight: bold; font-size: 11px;">Ideal</small>
                                <img src="${post.imageUrls.lpIdeal}" loading="lazy" style="width: 100%; border-radius: 4px; border: 1px solid #ddd; margin-top: 4px;">
                            </div>
                            <div style="text-align: center;">
                                <small style="color: #666; font-weight: bold; font-size: 11px;">Butterworth</small>
                                <img src="${post.imageUrls.lpButterworth}" loading="lazy" style="width: 100%; border-radius: 4px; border: 1px solid #ddd; margin-top: 4px;">
                            </div>
                            <div style="text-align: center;">
                                <small style="color: #666; font-weight: bold; font-size: 11px;">Gaussian</small>
                                <img src="${post.imageUrls.lpGaussian}" loading="lazy" style="width: 100%; border-radius: 4px; border: 1px solid #ddd; margin-top: 4px;">
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <strong style="color: #4267b2; margin-bottom: 8px; display: block; font-size: 14px;">🔼 Filtros Pasa-Altas:</strong>
                        <div class="post-images">
                            <div style="text-align: center;">
                                <small style="color: #666; font-weight: bold; font-size: 11px;">Ideal</small>
                                <img src="${post.imageUrls.hpIdeal}" loading="lazy" style="width: 100%; border-radius: 4px; border: 1px solid #ddd; margin-top: 4px;">
                            </div>
                            <div style="text-align: center;">
                                <small style="color: #666; font-weight: bold; font-size: 11px;">Butterworth</small>
                                <img src="${post.imageUrls.hpButterworth}" loading="lazy" style="width: 100%; border-radius: 4px; border: 1px solid #ddd; margin-top: 4px;">
                            </div>
                            <div style="text-align: center;">
                                <small style="color: #666; font-weight: bold; font-size: 11px;">Gaussian</small>
                                <img src="${post.imageUrls.hpGaussian}" loading="lazy" style="width: 100%; border-radius: 4px; border: 1px solid #ddd; margin-top: 4px;">
                            </div>
                        </div>
                    </div>
                    
                    <div class="post-actions">
                        <div class="action-buttons">
                            <button class="action-btn ${isLiked ? 'liked' : ''}" onclick="toggleLike('${post.id}')">
                                <span class="action-icon">👍</span>
                                <span>Me gusta${likes > 0 ? ` (${likes})` : ''}</span>
                            </button>
                            <button class="action-btn">
                                <span class="action-icon">💬</span>
                                <span>Comentar${comments.length > 0 ? ` (${comments.length})` : ''}</span>
                            </button>
                        </div>
                        
                        <div class="comment-form">
                            <input type="text" class="comment-input" placeholder="Escribe un comentario..." id="commentInput_${post.id}">
                            <button class="comment-submit-btn" onclick="submitComment('${post.id}')">Publicar</button>
                        </div>
                        
                        <div class="comments-list" id="comments_${post.id}">
                            ${comments.map(comment => `
                                <div class="comment">
                                    <div class="comment-header">
                                        <span class="comment-author">${comment.author}</span>
                                        <button class="delete-comment-btn" onclick="deleteComment('${post.id}', '${comment.id}')" title="Eliminar comentario">✕</button>
                                    </div>
                                    <div class="comment-text">${comment.text}</div>
                                    <div class="comment-time">${getTimeAgo(new Date(comment.timestamp))}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                feedContainer.appendChild(postDiv);
            });
        }
        
        function submitComment(postId) {
            const input = document.getElementById(`commentInput_${postId}`);
            const text = input.value.trim();
            
            if (text) {
                addComment(postId, text);
                input.value = '';
            }
        }
        
        function generateInterpretation() {
            return {
                title: '📊 Análisis de Filtros de Fourier - Team 13',
                sections: [
                    {
                        title: '🔽 Filtros Pasa-Bajas (Low-Pass)',
                        text: 'Estos filtros eliminan las altas frecuencias (detalles finos y ruido). El resultado es una imagen más suave. El filtro Ideal produce un corte abrupto pero puede generar "ringing". Butterworth ofrece una transición más suave, y Gaussian produce el suavizado más natural tipo "blur".'
                    },
                    {
                        title: '🔼 Filtros Pasa-Altas (High-Pass)',
                        text: 'Estos filtros eliminan las bajas frecuencias (información general) y resaltan los bordes y detalles. Son útiles para detección de contornos. El filtro Ideal es el más agresivo, Butterworth balancea detalle y suavidad, y Gaussian detecta bordes de forma más gradual.'
                    },
                    {
                        title: '💡 Aplicaciones Prácticas',
                        text: 'Los filtros pasa-bajas se usan para reducir ruido en imágenes médicas, suavizar fotos, y preprocesamiento. Los pasa-altas se usan en detección de bordes, realce de texturas, análisis de características, y reconocimiento de patrones.'
                    }
                ]
            };
        }
        
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return 'Hace unos segundos';
            if (seconds < 3600) return `Hace ${Math.floor(seconds / 60)} minutos`;
            if (seconds < 86400) return `Hace ${Math.floor(seconds / 3600)} horas`;
            return `Hace ${Math.floor(seconds / 86400)} días`;
        }
        
        // Hacer funciones globales
        window.processImage = processImage;
        window.publishToFeed = publishToFeed;
        window.toggleLike = toggleLike;
        window.submitComment = submitComment;
        window.deleteComment = deleteComment;
        window.deletePost = deletePost;
        window.updateGainValue = updateGainValue;
        window.reprocessWithNewGain = reprocessWithNewGain;
    </script>
</body>
</html>
